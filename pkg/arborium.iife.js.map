{"version":3,"file":"arborium.iife.js","sources":["../src/plugins-manifest.ts","../src/loader.ts","../src/detect.ts","../src/iife.ts"],"sourcesContent":["// AUTO-GENERATED by `cargo xtask gen-manifest` - DO NOT EDIT\n\n/** Version of plugin packages (all @arborium/* packages share this version) */\nexport const pluginVersion = \"0.0.0\";\n\n/** All available languages */\nexport const availableLanguages: string[] = [\n  \"ada\",\n  \"agda\",\n  \"asciidoc\",\n  \"asm\",\n  \"awk\",\n  \"bash\",\n  \"batch\",\n  \"c\",\n  \"c-sharp\",\n  \"caddy\",\n  \"capnp\",\n  \"clojure\",\n  \"cmake\",\n  \"commonlisp\",\n  \"cpp\",\n  \"css\",\n  \"d\",\n  \"dart\",\n  \"devicetree\",\n  \"diff\",\n  \"dockerfile\",\n  \"dot\",\n  \"elisp\",\n  \"elixir\",\n  \"elm\",\n  \"erlang\",\n  \"fish\",\n  \"fsharp\",\n  \"gleam\",\n  \"glsl\",\n  \"go\",\n  \"graphql\",\n  \"haskell\",\n  \"hcl\",\n  \"hlsl\",\n  \"html\",\n  \"idris\",\n  \"ini\",\n  \"java\",\n  \"javascript\",\n  \"jinja2\",\n  \"jq\",\n  \"json\",\n  \"julia\",\n  \"kdl\",\n  \"kotlin\",\n  \"lean\",\n  \"lua\",\n  \"markdown\",\n  \"matlab\",\n  \"meson\",\n  \"nginx\",\n  \"ninja\",\n  \"nix\",\n  \"objc\",\n  \"ocaml\",\n  \"perl\",\n  \"php\",\n  \"postscript\",\n  \"powershell\",\n  \"prolog\",\n  \"python\",\n  \"query\",\n  \"r\",\n  \"rescript\",\n  \"ron\",\n  \"ruby\",\n  \"rust\",\n  \"scala\",\n  \"scheme\",\n  \"scss\",\n  \"sparql\",\n  \"sql\",\n  \"ssh-config\",\n  \"starlark\",\n  \"svelte\",\n  \"swift\",\n  \"textproto\",\n  \"thrift\",\n  \"tlaplus\",\n  \"toml\",\n  \"tsx\",\n  \"typescript\",\n  \"typst\",\n  \"uiua\",\n  \"vb\",\n  \"verilog\",\n  \"vhdl\",\n  \"vim\",\n  \"vue\",\n  \"x86asm\",\n  \"xml\",\n  \"yaml\",\n  \"yuri\",\n  \"zig\",\n  \"zsh\",\n];","/**\n * Arborium loader - loads grammar plugins and highlights code.\n *\n * Architecture:\n * 1. Grammar registry is bundled at build time (no network request needed in production)\n *    - Can be overridden via pluginsUrl config for local development\n * 2. Load grammar wasm-bindgen modules on demand from @arborium/<lang> packages\n * 3. Parse and highlight using the grammar's tree-sitter parser\n */\n\nimport type { ParseResult, ArboriumConfig, Grammar, Session, Span, Injection } from \"./types.js\";\nimport { availableLanguages, pluginVersion } from \"./plugins-manifest.js\";\n\n// Default config\nexport const defaultConfig: Required<ArboriumConfig> = {\n  manual: false,\n  theme: \"one-dark\",\n  selector: \"pre code\",\n  cdn: \"jsdelivr\",\n  version: pluginVersion, // Precise version from manifest\n  pluginsUrl: \"\", // Empty means use bundled manifest\n  hostUrl: \"\", // Empty means use CDN based on version\n};\n\n// Rust host module (loaded on demand)\ninterface HostModule {\n  highlight: (language: string, source: string) => string;\n  isLanguageAvailable: (language: string) => boolean;\n}\nlet hostModule: HostModule | null = null;\nlet hostLoadPromise: Promise<HostModule | null> | null = null;\n\n// Merged config\nlet config: Required<ArboriumConfig> = { ...defaultConfig };\n\n// Grammar plugins cache\nconst grammarCache = new Map<string, GrammarPlugin>();\n\n// Languages we know are available (bundled at build time)\nconst knownLanguages: Set<string> = new Set(availableLanguages);\n\n// For local development: can override with pluginsUrl to load from dev server\ninterface LocalManifest {\n  entries: Array<{\n    language: string;\n    local_js: string;\n    local_wasm: string;\n  }>;\n}\nlet localManifest: LocalManifest | null = null;\nlet localManifestPromise: Promise<void> | null = null;\n\n/** Load local manifest if pluginsUrl is configured (for dev server) */\nasync function ensureLocalManifest(): Promise<void> {\n  if (!config.pluginsUrl) {\n    return;\n  }\n\n  if (localManifestPromise) {\n    return localManifestPromise;\n  }\n\n  localManifestPromise = (async () => {\n    console.debug(`[arborium] Loading local plugins manifest from: ${config.pluginsUrl}`);\n    const response = await fetch(config.pluginsUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to load plugins.json: ${response.status}`);\n    }\n    localManifest = await response.json();\n    console.debug(`[arborium] Loaded local manifest with ${localManifest?.entries.length} entries`);\n  })();\n\n  return localManifestPromise;\n}\n\n/** Get the CDN base URL for a grammar */\nfunction getGrammarBaseUrl(language: string): string {\n  // If we have a local manifest (dev mode), use the local path\n  if (localManifest) {\n    const entry = localManifest.entries.find((e) => e.language === language);\n    if (entry) {\n      // Extract base URL from local_js path (e.g., \"/langs/group-hazel/python/npm/grammar.js\" -> \"/langs/group-hazel/python/npm\")\n      return entry.local_js.substring(0, entry.local_js.lastIndexOf(\"/\"));\n    }\n  }\n\n  // Production: derive from language name using precise version\n  const cdn = config.cdn;\n  const version = config.version;\n  let baseUrl: string;\n  if (cdn === \"jsdelivr\") {\n    baseUrl = \"https://cdn.jsdelivr.net/npm\";\n  } else if (cdn === \"unpkg\") {\n    baseUrl = \"https://unpkg.com\";\n  } else {\n    baseUrl = cdn;\n  }\n  return `${baseUrl}/@arborium/${language}@${version}`;\n}\n\n/** wasm-bindgen plugin module interface */\ninterface WasmBindgenPlugin {\n  default: (wasmUrl: string) => Promise<void>;\n  language_id: () => string;\n  injection_languages: () => string[];\n  create_session: () => number;\n  free_session: (session: number) => void;\n  set_text: (session: number, text: string) => void;\n  parse: (session: number) => ParseResult;\n  cancel: (session: number) => void;\n}\n\n/** A loaded grammar plugin */\ninterface GrammarPlugin {\n  languageId: string;\n  injectionLanguages: string[];\n  module: WasmBindgenPlugin;\n  parse: (text: string) => ParseResult;\n}\n\n/** Load a grammar plugin */\nasync function loadGrammarPlugin(language: string): Promise<GrammarPlugin | null> {\n  // Check cache\n  const cached = grammarCache.get(language);\n  if (cached) {\n    console.debug(`[arborium] Grammar '${language}' found in cache`);\n    return cached;\n  }\n\n  // Load local manifest if in dev mode\n  await ensureLocalManifest();\n\n  // Check if language is known\n  if (\n    !knownLanguages.has(language) &&\n    !localManifest?.entries.some((e) => e.language === language)\n  ) {\n    console.debug(`[arborium] Grammar '${language}' not available`);\n    return null;\n  }\n\n  try {\n    const baseUrl = getGrammarBaseUrl(language);\n    const jsUrl = `${baseUrl}/grammar.js`;\n    const wasmUrl = `${baseUrl}/grammar_bg.wasm`;\n\n    console.debug(`[arborium] Loading grammar '${language}' from ${jsUrl}`);\n\n    // Dynamically import the wasm-bindgen generated JS module\n    const module = (await import(/* @vite-ignore */ jsUrl)) as WasmBindgenPlugin;\n\n    // Initialize the WASM module\n    await module.default(wasmUrl);\n\n    // Verify it loaded correctly\n    const loadedId = module.language_id();\n    if (loadedId !== language) {\n      console.warn(`[arborium] Language ID mismatch: expected '${language}', got '${loadedId}'`);\n    }\n\n    // Get injection languages\n    const injectionLanguages = module.injection_languages();\n\n    // Wrap as GrammarPlugin with session-based parsing\n    const plugin: GrammarPlugin = {\n      languageId: language,\n      injectionLanguages,\n      module,\n      parse: (text: string) => {\n        const session = module.create_session();\n        try {\n          module.set_text(session, text);\n          // wasm-bindgen returns ParseResult directly (or throws on error)\n          const result = module.parse(session);\n          return {\n            spans: result.spans || [],\n            injections: result.injections || [],\n          };\n        } catch (e) {\n          console.error(`[arborium] Parse error:`, e);\n          return { spans: [], injections: [] };\n        } finally {\n          module.free_session(session);\n        }\n      },\n    };\n\n    grammarCache.set(language, plugin);\n    console.debug(`[arborium] Grammar '${language}' loaded successfully`);\n    return plugin;\n  } catch (e) {\n    console.error(`[arborium] Failed to load grammar '${language}':`, e);\n    return null;\n  }\n}\n\n// Handle to plugin mapping for the host interface\nconst handleToPlugin = new Map<number, GrammarPlugin>();\nlet nextHandle = 1;\n\n/** Setup window.arboriumHost for the Rust host to call into */\nfunction setupHostInterface(): void {\n  (window as any).arboriumHost = {\n    /** Check if a language is available (sync) */\n    isLanguageAvailable(language: string): boolean {\n      return knownLanguages.has(language) || grammarCache.has(language);\n    },\n\n    /** Load a grammar and return a handle (async) */\n    async loadGrammar(language: string): Promise<number> {\n      const plugin = await loadGrammarPlugin(language);\n      if (!plugin) return 0; // 0 = not found\n\n      // Check if we already have a handle\n      for (const [handle, p] of handleToPlugin) {\n        if (p === plugin) return handle;\n      }\n\n      // Create new handle\n      const handle = nextHandle++;\n      handleToPlugin.set(handle, plugin);\n      return handle;\n    },\n\n    /** Parse text using a grammar handle (sync) */\n    parse(handle: number, text: string): ParseResult {\n      const plugin = handleToPlugin.get(handle);\n      if (!plugin) return { spans: [], injections: [] };\n      return plugin.parse(text);\n    },\n  };\n}\n\n/** Get the host URL based on config */\nfunction getHostUrl(): string {\n  if (config.hostUrl) {\n    return config.hostUrl;\n  }\n  // Use CDN\n  const cdn = config.cdn;\n  const version = config.version;\n  let baseUrl: string;\n  if (cdn === \"jsdelivr\") {\n    baseUrl = \"https://cdn.jsdelivr.net/npm\";\n  } else if (cdn === \"unpkg\") {\n    baseUrl = \"https://unpkg.com\";\n  } else {\n    baseUrl = cdn;\n  }\n  const versionSuffix = version === \"latest\" ? \"\" : `@${version}`;\n  return `${baseUrl}/@arborium/arborium${versionSuffix}/dist`;\n}\n\n/** Load the Rust host module */\nasync function loadHost(): Promise<HostModule | null> {\n  if (hostModule) return hostModule;\n  if (hostLoadPromise) return hostLoadPromise;\n\n  hostLoadPromise = (async () => {\n    // Setup the interface the host imports\n    setupHostInterface();\n\n    const hostUrl = getHostUrl();\n    const jsUrl = `${hostUrl}/arborium_host.js`;\n    const wasmUrl = `${hostUrl}/arborium_host_bg.wasm`;\n\n    console.debug(`[arborium] Loading host from ${jsUrl}`);\n    try {\n      const module = await import(/* @vite-ignore */ jsUrl);\n      await module.default(wasmUrl);\n\n      hostModule = {\n        highlight: module.highlight,\n        isLanguageAvailable: module.isLanguageAvailable,\n      };\n      console.debug(`[arborium] Host loaded successfully`);\n      return hostModule;\n    } catch (e) {\n      console.error(\"[arborium] Failed to load host:\", e);\n      return null;\n    }\n  })();\n\n  return hostLoadPromise;\n}\n\n/** Highlight source code */\nexport async function highlight(\n  language: string,\n  source: string,\n  _config?: ArboriumConfig,\n): Promise<string> {\n  // Try to use the Rust host (handles injections properly)\n  const host = await loadHost();\n  if (host) {\n    try {\n      return host.highlight(language, source);\n    } catch (e) {\n      console.warn(\"Host highlight failed, falling back to JS:\", e);\n    }\n  }\n\n  // Fallback to JS-only highlighting (no injection support)\n  const plugin = await loadGrammarPlugin(language);\n  if (!plugin) {\n    return escapeHtml(source);\n  }\n\n  const result = plugin.parse(source);\n  return spansToHtml(source, result.spans);\n}\n\n/** Load a grammar for direct use */\nexport async function loadGrammar(\n  language: string,\n  _config?: ArboriumConfig,\n): Promise<Grammar | null> {\n  const plugin = await loadGrammarPlugin(language);\n  if (!plugin) return null;\n\n  const { module } = plugin;\n\n  return {\n    languageId: () => plugin.languageId,\n    injectionLanguages: () => plugin.injectionLanguages,\n    highlight: async (source: string) => {\n      const result = plugin.parse(source);\n      return spansToHtml(source, result.spans);\n    },\n    parse: (source: string) => plugin.parse(source),\n    createSession: (): Session => {\n      const handle = module.create_session();\n      return {\n        setText: (text: string) => module.set_text(handle, text),\n        parse: () => {\n          try {\n            const result = module.parse(handle);\n            return {\n              spans: result.spans || [],\n              injections: result.injections || [],\n            };\n          } catch (e) {\n            console.error(`[arborium] Session parse error:`, e);\n            return { spans: [], injections: [] };\n          }\n        },\n        cancel: () => module.cancel(handle),\n        free: () => module.free_session(handle),\n      };\n    },\n    dispose: () => {\n      // No-op for now, plugins are cached\n    },\n  };\n}\n\n/** Convert spans to HTML */\nexport function spansToHtml(source: string, spans: Span[]): string {\n  // Sort spans by start position\n  const sorted = [...spans].sort((a, b) => a.start - b.start);\n\n  let html = \"\";\n  let pos = 0;\n\n  for (const span of sorted) {\n    // Skip overlapping spans\n    if (span.start < pos) continue;\n\n    // Add text before span\n    if (span.start > pos) {\n      html += escapeHtml(source.slice(pos, span.start));\n    }\n\n    // Get tag for capture\n    const tag = getTagForCapture(span.capture);\n    const text = escapeHtml(source.slice(span.start, span.end));\n\n    if (tag) {\n      html += `<a-${tag}>${text}</a-${tag}>`;\n    } else {\n      html += text;\n    }\n\n    pos = span.end;\n  }\n\n  // Add remaining text\n  if (pos < source.length) {\n    html += escapeHtml(source.slice(pos));\n  }\n\n  return html;\n}\n\n/** Get the short tag for a capture name */\nfunction getTagForCapture(capture: string): string | null {\n  if (capture.startsWith(\"keyword\") || capture === \"include\" || capture === \"conditional\") {\n    return \"k\";\n  }\n  if (capture.startsWith(\"function\") || capture.startsWith(\"method\")) {\n    return \"f\";\n  }\n  if (capture.startsWith(\"string\") || capture === \"character\") {\n    return \"s\";\n  }\n  if (capture.startsWith(\"comment\")) {\n    return \"c\";\n  }\n  if (capture.startsWith(\"type\")) {\n    return \"t\";\n  }\n  if (capture.startsWith(\"variable\")) {\n    return \"v\";\n  }\n  if (capture.startsWith(\"number\") || capture === \"float\") {\n    return \"n\";\n  }\n  if (capture.startsWith(\"operator\")) {\n    return \"o\";\n  }\n  if (capture.startsWith(\"punctuation\")) {\n    return \"p\";\n  }\n  if (capture.startsWith(\"tag\")) {\n    return \"tg\";\n  }\n  if (capture.startsWith(\"attribute\")) {\n    return \"at\";\n  }\n  return null;\n}\n\n/** Escape HTML special characters */\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\");\n}\n\n/** Get current config, optionally merging with overrides */\nexport function getConfig(overrides?: Partial<ArboriumConfig>): Required<ArboriumConfig> {\n  if (overrides) {\n    return { ...config, ...overrides };\n  }\n  return { ...config };\n}\n\n/** Set/merge config */\nexport function setConfig(newConfig: Partial<ArboriumConfig>): void {\n  config = { ...config, ...newConfig };\n}\n\n/** Check if a language is available */\nexport async function isLanguageAvailable(language: string): Promise<boolean> {\n  await ensureLocalManifest();\n  return (\n    knownLanguages.has(language) ||\n    (localManifest?.entries.some((e) => e.language === language) ?? false)\n  );\n}\n\n/** Get list of available languages */\nexport async function getAvailableLanguages(): Promise<string[]> {\n  await ensureLocalManifest();\n  // In dev mode, use local manifest if available\n  if (localManifest) {\n    return localManifest.entries.map((e) => e.language);\n  }\n  return Array.from(knownLanguages);\n}\n","/**\n * Simple language detection heuristics.\n * Not meant to be comprehensive - just catches common cases.\n */\n\n/** Shebang patterns */\nconst SHEBANG_PATTERNS: Array<[RegExp, string]> = [\n  [/^#!.*\\bpython[23]?\\b/, 'python'],\n  [/^#!.*\\bnode\\b/, 'javascript'],\n  [/^#!.*\\bdeno\\b/, 'typescript'],\n  [/^#!.*\\bbun\\b/, 'typescript'],\n  [/^#!.*\\bruby\\b/, 'ruby'],\n  [/^#!.*\\bperl\\b/, 'perl'],\n  [/^#!.*\\bphp\\b/, 'php'],\n  [/^#!.*\\bbash\\b/, 'bash'],\n  [/^#!.*\\bzsh\\b/, 'zsh'],\n  [/^#!.*\\bsh\\b/, 'bash'],\n  [/^#!.*\\blua\\b/, 'lua'],\n  [/^#!.*\\bawk\\b/, 'awk'],\n];\n\n/** Keyword fingerprints - first few unique keywords that identify a language */\nconst KEYWORD_FINGERPRINTS: Array<[RegExp, string]> = [\n  // Rust - distinctive keywords\n  [/\\b(fn|impl|trait|pub\\s+fn|let\\s+mut|&mut|->)\\b/, 'rust'],\n\n  // Go - distinctive keywords\n  [/\\b(func|package\\s+\\w+|import\\s+\\(|go\\s+func|chan\\s+\\w+)\\b/, 'go'],\n\n  // Python - distinctive patterns\n  [/\\b(def\\s+\\w+\\s*\\(|import\\s+\\w+|from\\s+\\w+\\s+import|class\\s+\\w+:)\\b/, 'python'],\n\n  // TypeScript - distinctive type annotations\n  [/:\\s*(string|number|boolean|void)\\b|\\binterface\\s+\\w+\\s*\\{/, 'typescript'],\n\n  // JavaScript - distinctive patterns (after TS check)\n  [/\\b(const|let|var)\\s+\\w+\\s*=|function\\s+\\w+\\s*\\(|=>\\s*\\{/, 'javascript'],\n\n  // Ruby - distinctive keywords\n  [/\\b(def\\s+\\w+|end\\b|do\\s*\\|.*\\||puts\\s+|require\\s+['\"])\\b/, 'ruby'],\n\n  // Java - distinctive patterns\n  [/\\b(public\\s+class|private\\s+\\w+|System\\.out\\.println)\\b/, 'java'],\n\n  // C++ - distinctive patterns\n  [/\\b(#include\\s*<|std::|template\\s*<|nullptr|cout\\s*<<)\\b/, 'cpp'],\n\n  // C - distinctive patterns (after C++ check)\n  [/\\b(#include\\s*[<\"]|printf\\s*\\(|int\\s+main\\s*\\(|void\\s+\\w+\\s*\\()\\b/, 'c'],\n\n  // C# - distinctive patterns\n  [/\\b(namespace\\s+\\w+|using\\s+System|public\\s+static\\s+void)\\b/, 'c-sharp'],\n\n  // PHP - distinctive patterns\n  [/<\\?php|\\$\\w+\\s*=/, 'php'],\n\n  // Swift - distinctive patterns\n  [/\\b(func\\s+\\w+|var\\s+\\w+:\\s*\\w+|let\\s+\\w+:\\s*\\w+|@objc)\\b/, 'swift'],\n\n  // Kotlin - distinctive patterns\n  [/\\b(fun\\s+\\w+|val\\s+\\w+|var\\s+\\w+:|data\\s+class)\\b/, 'kotlin'],\n\n  // Scala - distinctive patterns\n  [/\\b(def\\s+\\w+|val\\s+\\w+|var\\s+\\w+|object\\s+\\w+|case\\s+class)\\b/, 'scala'],\n\n  // Haskell - distinctive patterns\n  [/\\b(module\\s+\\w+|import\\s+qualified|data\\s+\\w+\\s*=|::\\s*\\w+\\s*->)\\b/, 'haskell'],\n\n  // Elixir - distinctive patterns\n  [/\\b(defmodule\\s+\\w+|def\\s+\\w+|defp\\s+\\w+|\\|>)\\b/, 'elixir'],\n\n  // Lua - distinctive patterns\n  [/\\b(local\\s+\\w+\\s*=|function\\s+\\w+\\.\\w+|require\\s*\\()\\b/, 'lua'],\n\n  // SQL - distinctive patterns\n  [/\\b(SELECT\\s+.*\\s+FROM|INSERT\\s+INTO|CREATE\\s+TABLE|ALTER\\s+TABLE)\\b/i, 'sql'],\n\n  // Shell/Bash - distinctive patterns\n  [/\\b(if\\s+\\[\\s*|then\\b|fi\\b|echo\\s+[\"']|export\\s+\\w+=)\\b/, 'bash'],\n\n  // YAML - distinctive patterns\n  [/^\\s*[\\w-]+:\\s*[\\w\\-\"'[{]|^---\\s*$/, 'yaml'],\n\n  // JSON - distinctive patterns\n  [/^\\s*\\{[\\s\\S]*\"[\\w-]+\":\\s*/, 'json'],\n\n  // TOML - distinctive patterns\n  [/^\\s*\\[[\\w.-]+\\]\\s*$|^\\s*\\w+\\s*=\\s*[\"'\\d\\[]/, 'toml'],\n\n  // HTML - distinctive patterns\n  [/<(!DOCTYPE|html|head|body|div|span|p|a\\s)/i, 'html'],\n\n  // CSS - distinctive patterns\n  [/^\\s*[\\w.#@][\\w\\s,#.:>+~-]*\\{[^}]*\\}|@media\\s|@import\\s/, 'css'],\n\n  // Markdown - distinctive patterns\n  [/^#{1,6}\\s+\\w|^\\s*[-*+]\\s+\\w|^\\s*\\d+\\.\\s+\\w|```\\w*\\n/, 'markdown'],\n\n  // XML - distinctive patterns\n  [/<\\?xml|<[\\w:-]+\\s+xmlns/, 'xml'],\n\n  // Dockerfile\n  [/^FROM\\s+\\w+|^RUN\\s+|^COPY\\s+|^ENTRYPOINT\\s+/m, 'dockerfile'],\n\n  // Nginx config\n  [/\\b(server\\s*\\{|location\\s+[\\/~]|proxy_pass\\s+)\\b/, 'nginx'],\n\n  // Zig\n  [/\\b(pub\\s+fn|const\\s+\\w+\\s*=|@import\\(|comptime)\\b/, 'zig'],\n];\n\n/**\n * Detect the language of a code snippet.\n * Returns null if detection fails.\n */\nexport function detectLanguage(source: string): string | null {\n  // Check shebang first (most reliable)\n  const firstLine = source.split('\\n')[0];\n  for (const [pattern, language] of SHEBANG_PATTERNS) {\n    if (pattern.test(firstLine)) {\n      return language;\n    }\n  }\n\n  // Check keyword fingerprints\n  for (const [pattern, language] of KEYWORD_FINGERPRINTS) {\n    if (pattern.test(source)) {\n      return language;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract language from class name.\n * Supports multiple patterns:\n * - \"language-rust\" -> \"rust\" (standard)\n * - \"lang-rust\" -> \"rust\" (common alternative)\n * - \"rust\" -> \"rust\" (docs.rs style, bare language name)\n */\nexport function extractLanguageFromClass(className: string): string | null {\n  // Try \"language-*\" pattern first (most specific)\n  const langMatch = className.match(/\\blanguage-(\\w+)\\b/);\n  if (langMatch) return langMatch[1];\n\n  // Try \"lang-*\" pattern\n  const shortMatch = className.match(/\\blang-(\\w+)\\b/);\n  if (shortMatch) return shortMatch[1];\n\n  // Try bare language names (for docs.rs compatibility)\n  // Only match known language names to avoid false positives\n  const knownLanguages = new Set([\n    'rust', 'javascript', 'typescript', 'python', 'ruby', 'go', 'java',\n    'c', 'cpp', 'csharp', 'php', 'swift', 'kotlin', 'scala', 'haskell',\n    'elixir', 'lua', 'sql', 'bash', 'shell', 'yaml', 'json', 'toml',\n    'html', 'css', 'xml', 'markdown', 'dockerfile', 'nginx', 'zig',\n    'text', 'plaintext', 'console', 'sh',\n  ]);\n\n  for (const cls of className.split(/\\s+/)) {\n    if (knownLanguages.has(cls.toLowerCase())) {\n      return cls.toLowerCase();\n    }\n  }\n\n  return null;\n}\n\n/**\n * Normalize language identifier (handle aliases)\n */\nexport function normalizeLanguage(lang: string): string {\n  const aliases: Record<string, string> = {\n    js: 'javascript',\n    ts: 'typescript',\n    py: 'python',\n    rb: 'ruby',\n    rs: 'rust',\n    sh: 'bash',\n    shell: 'bash',\n    yml: 'yaml',\n    cs: 'c-sharp',\n    csharp: 'c-sharp',\n    'c++': 'cpp',\n    'c#': 'c-sharp',\n    'f#': 'fsharp',\n    dockerfile: 'dockerfile',\n    docker: 'dockerfile',\n    makefile: 'make',\n    plaintext: 'text',\n    plain: 'text',\n    txt: 'text',\n  };\n\n  const lower = lang.toLowerCase();\n  return aliases[lower] || lower;\n}\n","/**\n * @arborium/arborium IIFE bundle\n *\n * Drop-in auto-highlighter that runs on page load.\n * Configuration via data attributes or window.Arborium object.\n */\n\nimport { loadGrammar, highlight, getConfig, setConfig, defaultConfig } from \"./loader.js\";\nimport { detectLanguage, extractLanguageFromClass, normalizeLanguage } from \"./detect.js\";\nimport type { ArboriumConfig } from \"./types.js\";\n\n// Capture current script immediately (before any async operations)\nconst currentScript = document.currentScript as HTMLScriptElement | null;\n\n/** Parse query parameters from script src URL */\nfunction getQueryParams(): URLSearchParams {\n  if (!currentScript?.src) return new URLSearchParams();\n  try {\n    const url = new URL(currentScript.src);\n    return url.searchParams;\n  } catch {\n    return new URLSearchParams();\n  }\n}\n\n/** Parse configuration from script data attributes and query params */\nfunction getConfigFromScript(): Partial<ArboriumConfig> {\n  if (!currentScript) return {};\n\n  const config: Partial<ArboriumConfig> = {};\n  const params = getQueryParams();\n\n  // Data attributes\n  if (currentScript.hasAttribute(\"data-manual\")) {\n    config.manual = true;\n  }\n\n  const theme = currentScript.getAttribute(\"data-theme\");\n  if (theme) config.theme = theme;\n\n  const selector = currentScript.getAttribute(\"data-selector\");\n  if (selector) config.selector = selector;\n\n  const cdn = currentScript.getAttribute(\"data-cdn\");\n  if (cdn) config.cdn = cdn;\n\n  const version = currentScript.getAttribute(\"data-version\");\n  if (version) config.version = version;\n\n  // Query parameters (for local testing)\n  const pluginsUrl = params.get(\"pluginsUrl\");\n  if (pluginsUrl) config.pluginsUrl = pluginsUrl;\n\n  const hostUrl = params.get(\"hostUrl\");\n  if (hostUrl) config.hostUrl = hostUrl;\n\n  return config;\n}\n\n/** Detect if we're running on a rustdoc-generated page */\nfunction isRustdocEnvironment(): boolean {\n  const generator = document.querySelector('meta[name=\"generator\"]');\n  return generator?.getAttribute(\"content\") === \"rustdoc\";\n}\n\n/** Map rustdoc theme names to Arborium theme IDs */\nfunction mapRustdocTheme(value?: string): string | null {\n  if (!value) return null;\n\n  const themeMap: Record<string, string> = {\n    light: \"rustdoc-light\",\n    dark: \"rustdoc-dark\",\n    ayu: \"rustdoc-ayu\",\n  };\n\n  if (themeMap[value]) {\n    return themeMap[value];\n  }\n\n  // Unknown theme value: return as-is or fallback to null\n  return null;\n}\n\n/** Detect the current theme from rustdoc or environment */\nfunction getAutoTheme(): string {\n  if (isRustdocEnvironment()) {\n    // Try data-theme attribute (used by both docs.rs and local rustdoc)\n    const rustdocTheme = mapRustdocTheme(document.documentElement.dataset.theme);\n    if (rustdocTheme) {\n      return rustdocTheme;\n    }\n  }\n\n  // Fall back to system preference\n  const isLight = window.matchMedia(\"(prefers-color-scheme: light)\").matches;\n  return isLight ? \"github-light\" : \"one-dark\";\n}\n\n/** Get merged configuration from all sources and apply to loader */\nfunction getMergedConfig(): Required<ArboriumConfig> {\n  // Priority: data attributes > window.Arborium > auto-detect > defaults\n  const windowConfig = window.Arborium || {};\n  const scriptConfig = getConfigFromScript();\n  const merged = { ...windowConfig, ...scriptConfig };\n\n  // Auto-detect theme if not explicitly set\n  if (!merged.theme) {\n    merged.theme = getAutoTheme();\n  }\n\n  // Apply to loader so host loading uses correct URLs\n  setConfig(merged);\n  return getConfig();\n}\n\n/** Find all code blocks that need highlighting */\nfunction findCodeBlocks(selector: string): HTMLElement[] {\n  return Array.from(document.querySelectorAll(selector));\n}\n\n/** Check if a code block already has syntax highlighting or semantic markup */\nfunction hasExistingHighlighting(block: HTMLElement): boolean {\n  // Check for common highlighting library markers\n  const highlightClasses = [\"hljs\", \"highlighted\", \"prism-code\", \"shiki\"];\n  for (const cls of highlightClasses) {\n    if (block.classList.contains(cls)) return true;\n  }\n\n  // Check if there are spans with syntax highlighting classes inside\n  // (highlight.js, prism, etc. use spans with classes)\n  const spans = block.querySelectorAll(\"span[class]\");\n  if (spans.length > 0) {\n    // If there are multiple spans with classes, likely already highlighted\n    // Be conservative: even a few spans suggest existing highlighting\n    const classedSpans = Array.from(spans).filter((s) => s.className && s.className.length > 0);\n    if (classedSpans.length >= 3) return true;\n  }\n\n  // Check for semantic markup (e.g., docs.rs uses <a> tags for type/function links)\n  // If there are links inside the code, it has meaningful markup we shouldn't destroy\n  const links = block.querySelectorAll(\"a\");\n  if (links.length >= 2) return true;\n\n  return false;\n}\n\n/** Get the language for a code block */\nfunction getLanguageForBlock(block: HTMLElement): string | null {\n  // Check data-lang attribute\n  const dataLang = block.getAttribute(\"data-lang\");\n  if (dataLang) return normalizeLanguage(dataLang);\n\n  // Check class=\"language-*\"\n  const className = block.className;\n  const classLang = extractLanguageFromClass(className);\n  if (classLang) return normalizeLanguage(classLang);\n\n  // Check parent element (often <pre> wraps <code>)\n  const parent = block.parentElement;\n  if (parent) {\n    const parentDataLang = parent.getAttribute(\"data-lang\");\n    if (parentDataLang) return normalizeLanguage(parentDataLang);\n\n    const parentClassLang = extractLanguageFromClass(parent.className);\n    if (parentClassLang) return normalizeLanguage(parentClassLang);\n  }\n\n  // Try auto-detection\n  const source = block.textContent || \"\";\n  return detectLanguage(source);\n}\n\n/** Get the CSS base URL */\nfunction getCssBaseUrl(): string {\n  const config = getMergedConfig();\n\n  if (config.hostUrl) {\n    return `${config.hostUrl}/themes`;\n  }\n\n  const cdn = config.cdn;\n  const version = config.version;\n\n  let baseUrl: string;\n  if (cdn === \"jsdelivr\") {\n    baseUrl = \"https://cdn.jsdelivr.net/npm\";\n  } else if (cdn === \"unpkg\") {\n    baseUrl = \"https://unpkg.com\";\n  } else {\n    baseUrl = cdn;\n  }\n\n  const versionSuffix = version === \"latest\" ? \"\" : `@${version}`;\n  return `${baseUrl}/@arborium/arborium${versionSuffix}/dist/themes`;\n}\n\n/** Inject base CSS (only once) */\nfunction injectBaseCSS(): void {\n  const baseId = \"arborium-base\";\n  if (document.getElementById(baseId)) return;\n\n  const cssUrl = `${getCssBaseUrl()}/base-rustdoc.css`;\n  console.debug(`[arborium] Loading base CSS: ${cssUrl}`);\n\n  const link = document.createElement(\"link\");\n  link.id = baseId;\n  link.rel = \"stylesheet\";\n  link.href = cssUrl;\n  document.head.appendChild(link);\n}\n\n// Track currently loaded theme\nlet currentThemeId: string | null = null;\n\n/** Inject theme CSS, removing any previously loaded theme */\nfunction injectThemeCSS(theme: string): void {\n  // Remove old theme if different\n  if (currentThemeId && currentThemeId !== theme) {\n    const oldLink = document.getElementById(`arborium-theme-${currentThemeId}`);\n    if (oldLink) {\n      oldLink.remove();\n      console.debug(`[arborium] Removed theme: ${currentThemeId}`);\n    }\n  }\n\n  const themeId = `arborium-theme-${theme}`;\n  if (document.getElementById(themeId)) {\n    currentThemeId = theme;\n    return;\n  }\n\n  const cssUrl = `${getCssBaseUrl()}/${theme}.css`;\n  console.debug(`[arborium] Loading theme: ${cssUrl}`);\n\n  const link = document.createElement(\"link\");\n  link.id = themeId;\n  link.rel = \"stylesheet\";\n  link.href = cssUrl;\n  document.head.appendChild(link);\n\n  currentThemeId = theme;\n}\n\n/** Highlight a single code block */\nasync function highlightBlock(\n  block: HTMLElement,\n  language: string,\n  config: ArboriumConfig,\n): Promise<void> {\n  const source = block.textContent || \"\";\n  if (!source.trim()) return;\n\n  try {\n    const html = await highlight(language, source, config);\n    block.innerHTML = html;\n    block.setAttribute(\"data-highlighted\", \"true\");\n    block.setAttribute(\"data-lang\", language);\n  } catch (err) {\n    console.warn(`[arborium] Failed to highlight ${language}:`, err);\n    // Don't modify the block on error\n  }\n}\n\n/** Main auto-highlight function */\nasync function autoHighlight(): Promise<void> {\n  const config = getMergedConfig();\n\n  // Inject base CSS (defines a-* selectors using variables)\n  injectBaseCSS();\n\n  // Inject theme CSS (defines the variables)\n  injectThemeCSS(config.theme);\n\n  // Find all code blocks\n  const blocks = findCodeBlocks(config.selector);\n  if (blocks.length === 0) return;\n\n  // Group blocks by language\n  const blocksByLanguage = new Map<string, HTMLElement[]>();\n  const unknownBlocks: HTMLElement[] = [];\n\n  for (const block of blocks) {\n    // Skip already highlighted blocks\n    if (block.hasAttribute(\"data-highlighted\")) continue;\n\n    // Skip blocks that appear to have existing syntax highlighting\n    // (e.g., docs.rs uses spans with classes for highlighting)\n    if (hasExistingHighlighting(block)) continue;\n\n    const language = getLanguageForBlock(block);\n    if (language) {\n      const existing = blocksByLanguage.get(language) || [];\n      existing.push(block);\n      blocksByLanguage.set(language, existing);\n    } else {\n      unknownBlocks.push(block);\n    }\n  }\n\n  // Load grammars in parallel for all detected languages\n  const languages = Array.from(blocksByLanguage.keys());\n  const loadPromises = languages.map((lang) =>\n    loadGrammar(lang, config).catch((err) => {\n      console.warn(`[arborium] Failed to load grammar for ${lang}:`, err);\n      return null;\n    }),\n  );\n\n  // Wait for all grammars to load\n  const grammars = await Promise.all(loadPromises);\n\n  // Highlight blocks for each loaded grammar\n  const highlightPromises: Promise<void>[] = [];\n\n  for (let i = 0; i < languages.length; i++) {\n    const language = languages[i];\n    const grammar = grammars[i];\n    if (!grammar) continue;\n\n    const languageBlocks = blocksByLanguage.get(language) || [];\n    for (const block of languageBlocks) {\n      highlightPromises.push(highlightBlock(block, language, config));\n    }\n  }\n\n  // Wait for all highlighting to complete\n  await Promise.all(highlightPromises);\n\n  // Log summary\n  const total = blocks.length;\n  const highlighted = blocks.filter((b) => b.hasAttribute(\"data-highlighted\")).length;\n  const skipped = unknownBlocks.length;\n\n  if (highlighted > 0 || skipped > 0) {\n    console.debug(\n      `[arborium] Highlighted ${highlighted}/${total} blocks` +\n        (skipped > 0 ? ` (${skipped} unknown language)` : \"\"),\n    );\n  }\n}\n\n/** Public API for manual highlighting */\nexport async function highlightAll(config?: ArboriumConfig): Promise<void> {\n  const mergedConfig = getConfig({ ...getMergedConfig(), ...config });\n  await autoHighlight();\n}\n\n/** Public API for highlighting a specific element */\nexport async function highlightElement(\n  element: HTMLElement,\n  language?: string,\n  config?: ArboriumConfig,\n): Promise<void> {\n  const mergedConfig = getConfig({ ...getMergedConfig(), ...config });\n  const lang = language || getLanguageForBlock(element);\n\n  if (!lang) {\n    console.warn(\"[arborium] Could not detect language for element\");\n    return;\n  }\n\n  await highlightBlock(element, lang, mergedConfig);\n}\n\n// Expose public API on window\n(window as any).arborium = {\n  highlightAll,\n  highlightElement,\n  loadGrammar,\n  highlight,\n  detectLanguage,\n  config: getMergedConfig(),\n};\n\n/** Re-highlight all blocks when theme changes */\nasync function onThemeChange(): Promise<void> {\n  const newTheme = getAutoTheme();\n\n  // Only update if theme actually changed\n  if (currentThemeId !== newTheme) {\n    // Update config\n    setConfig({ theme: newTheme });\n    (window as any).arborium.config = getMergedConfig();\n\n    // Inject new theme CSS\n    injectThemeCSS(newTheme);\n\n    // No need to re-highlight - CSS handles the colors\n    // The spans are already in place, just the theme CSS changes\n    console.debug(`[arborium] Theme changed to: ${newTheme}`);\n  }\n}\n\n/** Set up theme change watchers */\nfunction watchThemeChanges(): void {\n  // Watch for rustdoc theme attribute changes\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      const attr = mutation.attributeName;\n      if (attr === \"data-theme\" && isRustdocEnvironment()) {\n        onThemeChange();\n        break;\n      }\n    }\n  });\n  observer.observe(document.documentElement, { attributes: true });\n\n  // Watch for system color scheme changes\n  window\n    .matchMedia(\"(prefers-color-scheme: light)\")\n    .addEventListener(\"change\", () => onThemeChange());\n}\n\n// Auto-highlight on DOMContentLoaded (unless manual mode)\nconst config = getMergedConfig();\nif (!config.manual) {\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      autoHighlight();\n      watchThemeChanges();\n    });\n  } else {\n    // DOM already loaded\n    autoHighlight();\n    watchThemeChanges();\n  }\n}\n"],"names":["pluginVersion","availableLanguages","defaultConfig","hostModule","hostLoadPromise","config","grammarCache","knownLanguages","localManifest","localManifestPromise","ensureLocalManifest","response","getGrammarBaseUrl","language","entry","e","cdn","version","baseUrl","loadGrammarPlugin","cached","jsUrl","wasmUrl","module","loadedId","injectionLanguages","plugin","text","session","result","handleToPlugin","nextHandle","setupHostInterface","handle","p","getHostUrl","versionSuffix","loadHost","hostUrl","highlight","source","_config","host","escapeHtml","spansToHtml","loadGrammar","spans","sorted","a","b","html","pos","span","tag","getTagForCapture","capture","getConfig","overrides","setConfig","newConfig","SHEBANG_PATTERNS","KEYWORD_FINGERPRINTS","detectLanguage","firstLine","pattern","extractLanguageFromClass","className","langMatch","shortMatch","cls","normalizeLanguage","lang","aliases","lower","currentScript","getQueryParams","getConfigFromScript","params","theme","selector","pluginsUrl","isRustdocEnvironment","mapRustdocTheme","value","themeMap","getAutoTheme","rustdocTheme","getMergedConfig","windowConfig","scriptConfig","merged","findCodeBlocks","hasExistingHighlighting","block","highlightClasses","s","getLanguageForBlock","dataLang","classLang","parent","parentDataLang","parentClassLang","getCssBaseUrl","injectBaseCSS","baseId","cssUrl","link","currentThemeId","injectThemeCSS","oldLink","themeId","highlightBlock","err","autoHighlight","blocks","blocksByLanguage","unknownBlocks","existing","languages","loadPromises","grammars","highlightPromises","i","languageBlocks","total","highlighted","skipped","highlightAll","highlightElement","element","mergedConfig","onThemeChange","newTheme","watchThemeChanges","mutations","mutation"],"mappings":"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"}